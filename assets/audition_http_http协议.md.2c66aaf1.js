import{_ as t,c as l,o as e,V as a}from"./chunks/framework.4fdb28a6.js";const c=JSON.parse('{"title":"http","description":"","frontmatter":{},"headers":[],"relativePath":"audition/http/http协议.md","filePath":"audition/http/http协议.md","lastUpdated":null}'),i={name:"audition/http/http协议.md"},o=a('<h1 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h1><h2 id="http概述" tabindex="-1">HTTP概述 <a class="header-anchor" href="#http概述" aria-label="Permalink to &quot;HTTP概述&quot;">​</a></h2><p>HTTP ( HyperText Transfer Protocal)，全称为超文本传输协议。HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准。通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如&quot;HTTP/1.1 200 OK&quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><p>客户端 --&gt; 服务器（默认是80端口）--&gt; 服务器监听客户端的请求 --&gt; 收到请求 --(状态码，以及返回的内容，如请求的文件、错误消息、或者其它信息)--&gt; 客户端</p><h2 id="http特点" tabindex="-1">HTTP特点： <a class="header-anchor" href="#http特点" aria-label="Permalink to &quot;HTTP特点：&quot;">​</a></h2><ul><li>支持客户端、服务端模式</li><li>简单快速：客户向服务器请求服务时，只需要传送请求方法和路径。由于HTTP协议简单，使得通信速度比较快</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li><li>无连接：每次连接只处理一个请求，服务器处理完客户请求，收到用户的应答后，便断开连接，这种方式可以节省传输时间</li><li>无状态：无状态是指协议对于事物处理没有记忆能力。不对请求和响应之间的通信状态进行保存，缺少状态意味着如果后续处理需要前面的信息，则它必须重传</li><li>无状态协议解决办法： 1、通过、Cookie 2、通过Session会话保存</li></ul><h2 id="tcp-ip" tabindex="-1">TCP/IP <a class="header-anchor" href="#tcp-ip" aria-label="Permalink to &quot;TCP/IP&quot;">​</a></h2><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</p><h2 id="http与https的区别" tabindex="-1">HTTP与HTTPS的区别 <a class="header-anchor" href="#http与https的区别" aria-label="Permalink to &quot;HTTP与HTTPS的区别&quot;">​</a></h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，可以用抓包工具直接抓下来并且可见，而HTTPS则是利用了网景公司设计的SSL（Secure Sockets Layer）协议对HTTP协议传输的数据进行加密，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。抓包工具抓下来的是密文，大幅增加了中间人攻击的成本。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全</p><p>主要区别：</p><ol><li>HTTP的URL由<code>http://起始且默认使用端口80</code>，而HTTPS的URL由<code>https://起始且默认使用端口443</code></li><li>HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的 SSL 加密传输协议</li><li>HTTP的连接很简单，是无状态的，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全</li></ol><h2 id="ssl" tabindex="-1">ssl <a class="header-anchor" href="#ssl" aria-label="Permalink to &quot;ssl&quot;">​</a></h2><p>SSL（Secure Sockets Layer）是一种加密协议，用于在计算机网络上保证通信安全。它通过使用对称加密和非对称加密的组合来实现数据的机密性、完整性和身份验证。</p><h2 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-label="Permalink to &quot;对称加密&quot;">​</a></h2><p>对称加密是一种加密方式，使用<strong>相同的密钥</strong>对数据进行加密和解密。</p><h2 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-label="Permalink to &quot;非对称加密&quot;">​</a></h2><p>非对称加密<strong>使用一对密钥</strong>：公钥和私钥。公钥用于加密数据，而私钥用于解密数据。</p><h2 id="http1-0与http2-0的区别" tabindex="-1">HTTP1.0与HTTP2.0的区别 <a class="header-anchor" href="#http1-0与http2-0的区别" aria-label="Permalink to &quot;HTTP1.0与HTTP2.0的区别&quot;">​</a></h2><p>HTTP 2.0 的出现，相比于 HTTP 1.x ，大幅度的提升了 web 性能</p><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><h2 id="url的组成" tabindex="-1">URL的组成 <a class="header-anchor" href="#url的组成" aria-label="Permalink to &quot;URL的组成&quot;">​</a></h2><p>协议+主机名+路径+参数</p><h2 id="http请求" tabindex="-1">HTTP请求 <a class="header-anchor" href="#http请求" aria-label="Permalink to &quot;HTTP请求&quot;">​</a></h2><h3 id="请求行" tabindex="-1">请求行 <a class="header-anchor" href="#请求行" aria-label="Permalink to &quot;请求行&quot;">​</a></h3><p>请求行包括三个方面：请求方法、请求地址、协议版本</p><table><thead><tr><th style="text-align:left;">方法名</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:left;">GET</td><td style="text-align:left;">向指定的资源发出“显示”请求，使用 GET 方法应该只用在读取数据上，而不应该用于产生“副作用”的操作中</td></tr><tr><td style="text-align:left;">POST</td><td style="text-align:left;">指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求文本中。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。</td></tr><tr><td style="text-align:left;">PUT</td><td style="text-align:left;">向指定资源位置上传其最新内容</td></tr><tr><td style="text-align:left;">DELETE</td><td style="text-align:left;">请求服务器删除 Request-URI 所标识的资源</td></tr><tr><td style="text-align:left;">OPTIONS</td><td style="text-align:left;">使服务器传回该资源所支持的所有HTTP请求方法。用*来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作</td></tr><tr><td style="text-align:left;">HEAD</td><td style="text-align:left;">与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中关于该资源的信息（原信息或称元数据）</td></tr><tr><td style="text-align:left;">TRACE</td><td style="text-align:left;">显示服务器收到的请求，主要用于测试或诊断</td></tr><tr><td style="text-align:left;">CONNECT</td><td style="text-align:left;">HTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）</td></tr></tbody></table><h3 id="get与post的区别" tabindex="-1">GET与POST的区别： <a class="header-anchor" href="#get与post的区别" aria-label="Permalink to &quot;GET与POST的区别：&quot;">​</a></h3><ol><li>GET：一般用于信息获取，使用URL传递参数并且可见，传递参数数量有限</li><li>POST：一般用于提交数据，参数不可见，传递参数数量无限制</li></ol><p><strong>注意：</strong></p><p>安全性讲，get和post都一样，没啥所谓的哪个更安全,get请求参数在url地址上，直接暴露，post请求的参数放Request body部分，按F12也直接暴露了，所以没啥安全性可言</p><p>GET和POST有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包</p><p>原因是：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据） 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p><h3 id="什么情况下使用post请求" tabindex="-1">什么情况下使用POST请求： <a class="header-anchor" href="#什么情况下使用post请求" aria-label="Permalink to &quot;什么情况下使用POST请求：&quot;">​</a></h3><ol><li>无法使用缓存文件（更新服务器上的文件或数据库），GET能请求缓存，POST不能</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ol><h3 id="请求头" tabindex="-1">请求头 <a class="header-anchor" href="#请求头" aria-label="Permalink to &quot;请求头&quot;">​</a></h3><p>请求头可用于传递一些附加信息，格式为：键: 值，注意，冒号后面有一个空格：</p><ol><li>常见的请求 Header：</li></ol><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">Authorization</td><td style="text-align:left;">用于设置身份认证信息</td></tr><tr><td style="text-align:left;">User-Agent</td><td style="text-align:left;">用户标识，如：OS 和浏览器的类型和版本</td></tr><tr><td style="text-align:left;">If-Modified-Since</td><td style="text-align:left;">值为上一次服务器返回的Last-Modified值，用于确定某个资源是否被更改过，没有更改过就从缓存中读取</td></tr><tr><td style="text-align:left;">If-None-Match</td><td style="text-align:left;">值为上一次服务器返回的 ETag 值，一般会和If-Modified-Since</td></tr><tr><td style="text-align:left;">Cookie</td><td style="text-align:left;">已有的Cookie</td></tr><tr><td style="text-align:left;">Referer</td><td style="text-align:left;">标识请求引用自哪个地址，比如你从页面 A 跳转到页面 B 时，值为页面 A 的地址</td></tr><tr><td style="text-align:left;">Host</td><td style="text-align:left;">请求的主机和端口号</td></tr></tbody></table><ol start="2"><li>请求和响应常见通用的 Header</li></ol><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">Content-Type</td><td style="text-align:left;">请求体/响应体的类型，如：text/plain、application/json、x-www-form-urlencoded</td></tr><tr><td style="text-align:left;">Accept</td><td style="text-align:left;">说明接收的类型，可以多个值，用,(英文逗号)分开</td></tr><tr><td style="text-align:left;">Content-length</td><td style="text-align:left;">请求体/响应体的长度，单位字节</td></tr><tr><td style="text-align:left;">Content-Encoding</td><td style="text-align:left;">请求体/响应体的编码格式，如 gzip、deflate</td></tr><tr><td style="text-align:left;">Accept-Encoding</td><td style="text-align:left;">告知对方我方接受的 Content-Encoding</td></tr><tr><td style="text-align:left;">ETag</td><td style="text-align:left;">给当前资源的标识，和Last-Modified、If-None-Match、If-Modified-Since配合，用于缓存控制</td></tr><tr><td style="text-align:left;">Cache-Control</td><td style="text-align:left;">取值一般为no-cache、max-age=xx，xx为整数，表示资源缓存有效期（秒）</td></tr></tbody></table><h3 id="请求体" tabindex="-1">请求体 <a class="header-anchor" href="#请求体" aria-label="Permalink to &quot;请求体&quot;">​</a></h3><p>请求体（又叫请求正文）是 post 请求方式中的请求参数，以 key = value 形式进行存储，多个请求参数之间用&amp;连接，如果请求当中请求体，那么在请求头当中的 Content-Length 属性记录的就是该请求体的长度</p><h2 id="http响应" tabindex="-1">HTTP响应 <a class="header-anchor" href="#http响应" aria-label="Permalink to &quot;HTTP响应&quot;">​</a></h2><p>HTTP响应报文分为三个部分：<strong>响应状态行，响应头，响应体</strong></p><h3 id="响应状态行" tabindex="-1">响应状态行 <a class="header-anchor" href="#响应状态行" aria-label="Permalink to &quot;响应状态行&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">状态码</th><th style="text-align:left;">对应的信息</th></tr></thead><tbody><tr><td style="text-align:left;">1XX</td><td style="text-align:left;">提示信息—表示请求已接收，继续处理</td></tr><tr><td style="text-align:left;">2XX</td><td style="text-align:left;">用于表示请求已被成功接收、理解、接收</td></tr><tr><td style="text-align:left;">3XX</td><td style="text-align:left;">用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向</td></tr><tr><td style="text-align:left;">4XX</td><td style="text-align:left;">客户端错误—请求有语法错误或者请求无法实现</td></tr><tr><td style="text-align:left;">5XX</td><td style="text-align:left;">服务器端错误—服务器未能实现合法的请求</td></tr></tbody></table><h3 id="常见状态码" tabindex="-1">常见状态码 <a class="header-anchor" href="#常见状态码" aria-label="Permalink to &quot;常见状态码&quot;">​</a></h3><ol><li><strong>2XX 成功</strong><ol><li><strong>200</strong> （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。</li></ol></li><li><strong>3XX 重定向</strong><ol><li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</li><li><strong>301</strong> （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li><li><strong>302</strong> （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li><strong>304</strong> （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ol></li><li><strong>4XX 客户端错误</strong><ol><li><strong>400</strong> （错误请求） 服务器不理解请求的语法。</li><li><strong>401</strong> （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li><strong>403</strong> （禁止） 服务器拒绝请求。</li><li><strong>404</strong> （未找到） 服务器找不到请求的网页。</li><li>405 （方法禁用） 禁用请求中指定的方法。</li><li>406 （不接受） 无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li><strong>408</strong> （请求超时） 服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</li><li>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</li></ol></li><li><strong>5XX 服务器错误</strong><ol><li><strong>500</strong> （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li><li><strong>503</strong> （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</li></ol></li></ol><h3 id="响应头-响应体" tabindex="-1">响应头 响应体 <a class="header-anchor" href="#响应头-响应体" aria-label="Permalink to &quot;响应头 响应体&quot;">​</a></h3><h2 id="浏览器输入url按回车背后经历了哪些" tabindex="-1">浏览器输入url按回车背后经历了哪些 <a class="header-anchor" href="#浏览器输入url按回车背后经历了哪些" aria-label="Permalink to &quot;浏览器输入url按回车背后经历了哪些&quot;">​</a></h2><p><a href="https://juejin.cn/post/6844903922084085773" target="_blank" rel="noreferrer">参考这篇博文</a></p><ol><li>URL 解析</li><li>DNS 查询(获取网站的ip地址，向 DNS 服务器发送查询请求，通过网址获取ip地址)</li><li>TCP 连接</li><li>客户端向服务器发请求(http协议)</li><li>服务器处理请求，返回响应(http协议)</li><li>客户端接受响应</li><li>渲染页面</li></ol><h3 id="url-解析" tabindex="-1">URL 解析 <a class="header-anchor" href="#url-解析" aria-label="Permalink to &quot;URL 解析&quot;">​</a></h3><ol><li>地址解析,首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</li><li>会使用 HSTS 强制客户端使用 HTTPS 访问页面</li><li>浏览器还会进行一些额外的操作，比如安全检查、访问限制</li><li>检查缓存</li></ol><h3 id="dns-查询" tabindex="-1">DNS 查询 <a class="header-anchor" href="#dns-查询" aria-label="Permalink to &quot;DNS 查询&quot;">​</a></h3><ol><li>浏览器缓存,浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</li><li>操作系统缓存,操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</li><li>路由器缓存</li><li>ISP DNS 缓存</li></ol><h3 id="tcp-连接" tabindex="-1">TCP 连接 <a class="header-anchor" href="#tcp-连接" aria-label="Permalink to &quot;TCP 连接&quot;">​</a></h3><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><ol><li>应用层：发送 HTTP 请求 -软件层面</li><li>传输层：TCP 传输报文 -负责对数据拆分</li><li>网络层：IP协议查询Mac地址 -添加信息</li><li>链路层：以太网协议 -传输信息</li></ol><h3 id="处理请求" tabindex="-1">处理请求 <a class="header-anchor" href="#处理请求" aria-label="Permalink to &quot;处理请求&quot;">​</a></h3><p>服务器处理收到的请求，将数据返回至浏览器</p><h3 id="浏览器收到http响应" tabindex="-1">浏览器收到HTTP响应 <a class="header-anchor" href="#浏览器收到http响应" aria-label="Permalink to &quot;浏览器收到HTTP响应&quot;">​</a></h3><p>浏览器解码响应，如果响应可以缓存，则存入缓存。</p><h3 id="渲染页面" tabindex="-1">渲染页面 <a class="header-anchor" href="#渲染页面" aria-label="Permalink to &quot;渲染页面&quot;">​</a></h3><h2 id="tcp-建立连接是三次握手-而断开连接是四次挥手。" tabindex="-1">TCP 建立连接是三次握手，而断开连接是四次挥手。 <a class="header-anchor" href="#tcp-建立连接是三次握手-而断开连接是四次挥手。" aria-label="Permalink to &quot;TCP 建立连接是三次握手，而断开连接是四次挥手。&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手判断服务端的接收、发送能力，客户端的接收、发送能力是否是正常的</p><ol><li>第一次握手就是客户端给服务器端发送一个报文，客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次就是服务器收到报文之后，会应答一个报文给客户端，服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手就是客户端收到报文后再给服务器发送一个报文，三次握手就成功了。客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ol><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><ol><li>第一次挥手：客户端发送一个 FIN 报文，等待服务端的确认。此时客户端处于<strong>FIN_WAIT1</strong>状态。</li><li>服务端收到 FIN 之后，会发送 ACK 报文，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</li><li>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，此时服务端处于<strong>LAST_ACK</strong>的状态。</li><li>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，此时客户端处于<strong>TIME_WAIT</strong>状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于<strong>CLOSED</strong>状态。</li></ol><h2 id="ip" tabindex="-1">ip <a class="header-anchor" href="#ip" aria-label="Permalink to &quot;ip&quot;">​</a></h2><p>IP（Internet Protocol）是用于在网络中标识和定位设备的地址。在 IP 地址中，有内网 IP 和公网 IP，同时还有子网掩码用于定义 IP 地址的网络部分和主机部分。</p><h2 id="tcp和udp" tabindex="-1">tcp和udp <a class="header-anchor" href="#tcp和udp" aria-label="Permalink to &quot;tcp和udp&quot;">​</a></h2><p>TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种在计算机网络中常用的传输层协议，它们在数据传输方式、可靠性、连接性等方面存在一些区别。</p><ul><li>连接性：TCP 是面向<strong>连接</strong>的协议，通过三次握手建立可靠的连接，确保数据的可靠传输。UDP <strong>是无连接的协议</strong>，数据包在发送之前不需要建立连接。</li><li>数据传输方式：TCP 提供<code>面向字节流的数据传输方式</code>，将数据切分为大小不等的数据段进行传输，并确保数据的顺序和完整性。UDP 则以<code>数据报的形式传输数据</code>，每个数据报都是独立的单元，可能会以<strong>不同的顺序</strong>到达目的地。</li><li>可靠性：TCP 提供<strong>可靠</strong>的数据传输，通过确认、重传和拥塞控制等机制，确保数据的完整性和顺序性。UDP 不提供<strong>可靠</strong>性保证，它只是简单地将数据报发送出去，不关心数据是否到达目的地。</li><li>效率：由于 TCP 需要维护连接状态和保证数据的可靠传输，因此相对而言会增加一定的开销，使得数据传输效率较低。而 UDP 没有这些开销，<strong>传输效率较高</strong>。</li><li>应用场景：TCP 适用于要求数据传输的可靠性和顺序性的应用，如文件传输、网页浏览、电子邮件等。UDP 适用于实时性要求较高、对数据可靠性要求较低的应用，如音频和视频流媒体、实时游戏等。</li></ul><p>总结来说，<code>TCP 提供可靠的、面向连接的数据传输，确保数据的完整性和顺序性</code>，适用于对数据可靠性和顺序性有要求的应用；<code>UDP 提供无连接的、不可靠的数据传输，数据传输速度快，不保证数据的完整性和顺序性</code>，适用于实时性要求较高、对数据可靠性要求较低的应用。选择使用 TCP 还是 UDP 取决于具体的应用需求。</p><h2 id="http无状态的协议" tabindex="-1">HTTP无状态的协议 <a class="header-anchor" href="#http无状态的协议" aria-label="Permalink to &quot;HTTP无状态的协议&quot;">​</a></h2><p>HTTP（Hypertext Transfer Protocol）是一种无状态的协议。</p><p>无状态指的是在每个独立的 HTTP 请求之间，<strong>服务器不会保留任何关于客户端的状态信息</strong>。每个请求都是独立的，服务器无法识别出不同请求来自同一个客户端。这意味着服务器不能基于之前的请求状态来处理当前的请求。它使得服务器可以独立地处理每个请求，不需要为每个客户端维护状态信息，从而更容易实现负载均衡和横向扩展。</p><p>使用 Cookie、Session、Token 来维护状态</p><h2 id="cookie、session、token" tabindex="-1">cookie、session、token <a class="header-anchor" href="#cookie、session、token" aria-label="Permalink to &quot;cookie、session、token&quot;">​</a></h2><p>Web应用程序中管理用户认证和授权的机制</p><p>Cookie：Cookie 是一种<strong>存储在客户端（通常是浏览器）的小型文本文件</strong>，由服务器通过 <strong>HTTP 响应头</strong>设置并发送给客户端。浏览器会在后续的请求中将 <strong>Cookie 自动包含在 HTTP 请求头</strong>中发送给服务器。Cookie 主要用于在客户端存储有<strong>关用户的一些状态信息或标识符</strong>，以便服务器在后续请求中进行识别和处理。Cookie 可以设置过期时间，可以是会话级别的（在浏览器关闭后失效）或持久性的（在一定时间后失效）。</p><p>Session：Session 是一种服务器端的状态管理机制。当用户<strong>进行身份认证</strong>后，服务器会为该用户<strong>创建一个唯一的 Session 对象</strong>，并为该对象<strong>分配一个唯一的标识符（Session ID）</strong>。Session ID 通常<strong>通过 Cookie 或 URL 参数的方式发送给客户端</strong>，并在后续的请求中<strong>通过 Cookie 或参数传递给服务器</strong>。服务器根据 Session ID 识别用户，并在<code>服务器端存储和管理与该用户相关的状态信息</code>。Session 通常存储在服务器的内存或持久化存储（如数据库）中，<code>需要在服务器上维护状态</code>，可以存储更多敏感的用户信息。</p><p>Token：Token 是一种<strong>无状态的身份验证机制</strong>。在用户<strong>进行身份认证</strong>后，服务器会生成一个加密的令牌（Token）并返回给客户端。客户端在后续的请求中将该 <strong>Token 包含在请求头</strong>中发送给服务器进行身份验证。服务器在接收到 Token 后解密并验证其有效性，从而确定用户的身份。Token 可以包含一些用户信息，但通常不存储在服务器端，而是在令牌本身进行加密和验证。常见的 Token 实现方式包括 JSON Web Token (JWT)。 Token 的优势在于它能够避免服务器上的Session存储，因为<code>Token本身就包含了认证信息，无需服务器去维护状态</code>，</p><h2 id="进程和线程" tabindex="-1">进程和线程 <a class="header-anchor" href="#进程和线程" aria-label="Permalink to &quot;进程和线程&quot;">​</a></h2><p>进程和线程是操作系统中用于执行任务的两个基本概念。 进程（Process）是指正在执行的程序的实例。 线程（Thread）是进程中的执行单元。一个进程可以拥有多个线程，</p>',91),r=[o];function n(s,d,h,T,P,g){return e(),l("div",null,r)}const f=t(i,[["render",n]]);export{c as __pageData,f as default};
