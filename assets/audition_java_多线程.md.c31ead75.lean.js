import{_ as t,c,E as a,B as l,z as o,V as p,a as s,G as r,o as D}from"./chunks/framework.4fdb28a6.js";const y="/ljtui2/java/1571652681276.png",A="/ljtui2/java/1571655104091.png",C="/ljtui2/java/1571732060388.png",F="/ljtui2/java/1571735388181.png",e="/ljtui2/java/1571735465100.png",i="/ljtui2/java/1571735607347.png",E="/ljtui2/java/1571735715977.png",u="/ljtui2/java/1571735904991.png",d="/ljtui2/java/1571736824748.png",h="/ljtui2/java/1571743818653.png",g="/ljtui2/java/1571744627663.png",f="/ljtui2/java/1571746088704.png",m="/ljtui2/java/1571794778139.png",b="/ljtui2/java/1571817059527.png",v="/ljtui2/java/1571817085047.png",T="/ljtui2/java/1571817628904.png",_="/ljtui2/java/1571818176635.png",S="/ljtui2/java/1571818465276.png",x="/ljtui2/java/1571818597998.png",B="/ljtui2/java/1571818747880.png",j="/ljtui2/java/1571905221097.png",q="/ljtui2/java/1571880094854.png",k="/ljtui2/java/1571901607504.png",Vs=JSON.parse('{"title":"1 线程状态","description":"","frontmatter":{},"headers":[],"relativePath":"audition/java/多线程.md","filePath":"audition/java/多线程.md","lastUpdated":null}'),w={name:"audition/java/多线程.md"},P=p("",62),I=s("**获取线程池的方法**"),V=p("",5),N=s("**ExecutorService中的常见方法**"),R=p("",2),L=s("**案例1**"),M=p("",10),O=s("**案例2**"),H=p("",6),U=s("**案例3**"),K=p("",6),z=s("**案例4**"),W=p("",6),G=s("**案例5**"),J=p("",55),Q=s("**案例演示1**"),$=p("",5),Y=s("**案例演示2**"),Z=p("",5),X=s("**案例演示3**"),ss=p("",5),ns=s("**案例演示4**"),as=p("",165),ls={start:"5"},ps=s("线程1重新获取内存值V作为当前A的值，并重新计算想要修改的新值。此时对线程1来说，A = 11，B = 12。这个重新尝试的过程被称为"),os=o("strong",null,"自旋",-1),es=s("。"),ts=p("",24),cs=s("**案例1**"),rs=p("",9),Ds=s("**案例2**"),ys=p("",4),As=s("**Hashtable保证线程安全的原理**"),Cs=p("",7),Fs=s("**案例3**"),is=p("",7),Es=s("**ConcurrentHashMap中的重要成员变量**"),us=p("",4),ds=s("元素所在的Segment即可(这种锁被称为"),hs=o("strong",null,"分段锁",-1),gs=s(")，其他Segment无需加锁，从而产生锁竞争的概率大大减小，提高了并发读写的效率。该种实现方式的缺点是hash过程比普通的HashMap要长"),fs=o("p",null,"(因为需要进行两次hash操作)。",-1),ms=s("**ConcurrentHashMap的put方法源码分析**"),bs=p("",6),vs=s("**ConcurrentHashMap中的重要成员变量**"),Ts=p("",3),_s=s("**ConcurrentHashMap的put方法源码分析**"),Ss=p("",94);function xs(Bs,js,qs,ks,ws,Ps){const n=r("font");return D(),c("div",null,[P,a(n,{color:"blue",size:"3"},{default:l(()=>[I]),_:1}),V,a(n,{color:"blue",size:"3"},{default:l(()=>[N]),_:1}),R,a(n,{color:"blue",size:"3"},{default:l(()=>[L]),_:1}),M,a(n,{color:"blue",size:"3"},{default:l(()=>[O]),_:1}),H,a(n,{color:"blue",size:"3"},{default:l(()=>[U]),_:1}),K,a(n,{color:"blue",size:"3"},{default:l(()=>[z]),_:1}),W,a(n,{color:"blue",size:"3"},{default:l(()=>[G]),_:1}),J,a(n,{color:"blue",size:"3"},{default:l(()=>[Q]),_:1}),$,a(n,{color:"blue",size:"3"},{default:l(()=>[Y]),_:1}),Z,a(n,{color:"blue",size:"3"},{default:l(()=>[X]),_:1}),ss,a(n,{color:"blue",size:"3"},{default:l(()=>[ns]),_:1}),as,o("ol",ls,[o("li",null,[ps,a(n,{color:"red",size:"4"},{default:l(()=>[os]),_:1}),es])]),ts,a(n,{color:"blue",size:"3"},{default:l(()=>[cs]),_:1}),rs,a(n,{color:"blue",size:"3"},{default:l(()=>[Ds]),_:1}),ys,a(n,{color:"blue",size:"3"},{default:l(()=>[As]),_:1}),Cs,a(n,{color:"blue",size:"3"},{default:l(()=>[Fs]),_:1}),is,a(n,{color:"blue",size:"3"},{default:l(()=>[Es]),_:1}),us,o("p",null,[ds,a(n,{size:"3",color:"red"},{default:l(()=>[hs]),_:1}),gs]),fs,a(n,{color:"blue",size:"3"},{default:l(()=>[ms]),_:1}),bs,a(n,{color:"blue",size:"3"},{default:l(()=>[vs]),_:1}),Ts,a(n,{color:"blue",size:"3"},{default:l(()=>[_s]),_:1}),Ss])}const Ns=t(w,[["render",xs]]);export{Vs as __pageData,Ns as default};
